var documenterSearchIndex = {"docs":
[{"location":"#MinHash.jl","page":"Home","title":"MinHash.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Efficient minhashing in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"MinHash.jl offers generic, efficient MinHash sketching, and functions to efficiently compute the number of shared minhashes between sketches. This package is envisioned to be used as a dependency for other Julia packages that needs minhashing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The API is very simple. Below is a short demonstration - read the docstrings below for more info.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MinHash\n\njulia> hasher = MinHasher(100) # Same as MinHasher{hash}(100), keep 100 hashes\nMinHasher{hash}:\n hashes:  0 / 100\n maxhash: < uninitialized >\n hashset: HashSet(0 / 512)\n\njulia> update!(hasher, 'a':'z') # update with any iterable\nMinHasher{hash}:\n hashes:  26 / 100\n maxhash: < uninitialized >\n hashset: HashSet(26 / 512)\n\njulia> update!(hasher, 1:100) # only 100 hashes are kept\nMinHasher{hash}:\n hashes:  100 / 100\n maxhash: 0xd0196f660622f483\n hashset: HashSet(126 / 512)\n\njulia> sk = MinHashSketch(hasher) # can be used on noninitialized hasher\nMinHashSketch:\n hashes:  100 / 100\n maxhash: 0xd0196f660622f483\n\njulia sk2 = sketch(1:1000, 100) # quickly keep 100 hashes of 1:1000\nMinHashSketch:\n hashes:  100 / 100\n maxhash: 0xfff598f76319355e\n\njulia> intersectionlength(sk, sk2) # calc number of hashes in sk and sk2\n80","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MinHash]","category":"page"},{"location":"#MinHash.HashSet","page":"Home","title":"MinHash.HashSet","text":"HashSet(N::Integer)\n\nConstruct a HashSet with at least N slots. A HashSet contains UInt hash values and is optimized for quick inserts and membership test.\n\nA HashSet is a completely unsafe type internal type, not to be used unless you know what you are doing.\n\n\n\n\n\n","category":"type"},{"location":"#MinHash.MinHashSketch","page":"Home","title":"MinHash.MinHashSketch","text":"MinHashSketch\n\nHolds the N smallest hashes of an iterable. Construct from a MinHasher.\n\nExamples\n\njulia> x = MinHashSketch(update!(MinHasher(10), 1:1000))\nMinHashSketch:\n hashes:  10 / 10\n maxhash: 0x0214ce7a1c004d40\n\njulia> length(x)\n10\n\n\n\n\n\n","category":"type"},{"location":"#MinHash.MinHasher","page":"Home","title":"MinHash.MinHasher","text":"MinHasher{F}\n\nA type used to minhash any iterable object with function F.\n\nSee also: update!, minhash\n\n\n\n\n\n","category":"type"},{"location":"#MinHash.intersectionlength-Tuple{AbstractVector{MinHashSketch}}","page":"Home","title":"MinHash.intersectionlength","text":"intersectionlength(v::AbstractVector{MinHashSketch})\n\nReturn a length(v) square Matrix{Int} where the [i, j] where i > j'th cell contain the number of hashes in both v[i] and v[j].\n\nExamples\n\njulia> v = [sketch((1:1000) .+ (300*i), 100) for i in 1:4];\n\njulia> intersectionlength(v)\n4Ã—4 Array{Int64,2}:\n  0   0   0  0\n 64   0   0  0\n 27  58   0  0\n  8  34  73  0\n\n\n\n\n\n","category":"method"},{"location":"#MinHash.intersectionlength-Tuple{MinHashSketch, MinHashSketch}","page":"Home","title":"MinHash.intersectionlength","text":"intersectionlength(y::MinHashSketch, y::MinHashSketch)\n\nCount number of hashes in both x and y more effectively than using ordinary set operations.\n\nExamples\n\njulia> x = minhash(1:10000, 100); y = minhash(5000:15000, 100);\n\njulia> intersectionlength(x, y)\n49\n\n\n\n\n\n","category":"method"},{"location":"#MinHash.minhash-Tuple{Any, Any, Integer}","page":"Home","title":"MinHash.minhash","text":"minhash([F=hash], it, s::Integer)\n\nHash every element of iterable it using function F, and return a MinHashSketch containing at most the s smallest hashes.\n\nExamples:\n\njulia> minhash(\"ACGDEFG\", 3)\nMinHashSketch:\n hashes:  3 / 3\n maxhash: 0x3e1b023d3c92ff8f\n\nSee also: update!\n\n\n\n\n\n","category":"method"},{"location":"#MinHash.setfirst!-Tuple{Vector{T} where T, Any, Base.Order.Ordering}","page":"Home","title":"MinHash.setfirst!","text":"Replace root node in heap, preserving heap property\n\n\n\n\n\n","category":"method"},{"location":"#MinHash.update!-Tuple{MinHasher, Any}","page":"Home","title":"MinHash.update!","text":"update!(s::MinHasher, it)\n\nAdd hashes of all elements of iterable it to MinHasher s.\n\nSee also: minhash\n\n\n\n\n\n","category":"method"}]
}
